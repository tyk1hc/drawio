<mxfile host="app.diagrams.net" agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:128.0) Gecko/20100101 Firefox/128.0" version="28.1.2">
  <diagram name="Page-1" id="a_4ZZJJK4eQopy7NkvL7">
    <mxGraphModel dx="914" dy="493" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="850" pageHeight="1100" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="b6esr0sAbmWRh-eSNhls-1" value="Given an array of integers arr, create a function that returns an array that contains the values of arr without duplicates (the order doesn&#39;t matter)." style="text;html=1;align=left;verticalAlign=middle;whiteSpace=wrap;rounded=0;fontSize=14;" vertex="1" parent="1">
          <mxGeometry x="80" y="80" width="720" height="40" as="geometry" />
        </mxCell>
        <mxCell id="b6esr0sAbmWRh-eSNhls-3" value="&lt;div&gt;def removeDuplicates(arr)&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;visited = {}&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;for element in arr:&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;visited[element] = True&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;return list(visited.keys())&lt;br&gt;&lt;/div&gt;" style="text;html=1;align=left;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="150" y="1110" width="400" height="190" as="geometry" />
        </mxCell>
        <mxCell id="b6esr0sAbmWRh-eSNhls-4" value="&lt;div&gt;&lt;font&gt;&lt;b&gt;Solution 1:&lt;/b&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font&gt;&lt;br&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font&gt;We put n = length of arr&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font&gt;&lt;br&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font&gt;Time complexity: O(n2) &lt;br&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font&gt;&lt;br&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font&gt;Explanation:&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font&gt;The loop is traversing elements of arr, so it does n iterations, and at each iteration, we are checking if the element is not in noDuplicatesArr. And searching for an element in an unsorted array has an O(n) cost where n is the number of elements in it.&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font&gt;&lt;br&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font&gt;Cost of searching for the element in noDuplicatesArr:&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font&gt;1st iteration:&amp;nbsp; noDuplicatesArr has 0 elements --&amp;gt; cost: 0&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font&gt;2nd iteration: noDuplicatesArr has 1 element&amp;nbsp; --&amp;gt; cost: 1&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font&gt;3rd iteration: noDuplicatesArr has 2 elements --&amp;gt; cost: 2&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font&gt;&lt;br&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font&gt;...&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font&gt;&lt;br&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font&gt;nth iteration: noDuplicatesArr has n - 1 elements --&amp;gt; cost: n - 1&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font&gt;&lt;br&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font&gt;The sum is 0 + 1 + 2 + ... + (n-1), it&#39;s the sum of integers from 0 to n - 1, which is equal to n(n-1)/2.&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font&gt;T(n) = n(n-1)/2 = (n2-n)/2 = n2/2 - n/2, we take the greatest term, we remove the constant, and we get a time complexity of O(n2).&lt;br&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font&gt;&lt;br&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font&gt;Space complexity: O(n).&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font&gt;Explanation:&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font&gt;We&#39;re using an extra array that will contain n elements in the worst case, when there are no duplicates in arr, so:&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font&gt;S(n) = O(n).&lt;br&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font&gt;&lt;br&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font&gt;&lt;br&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;b&gt;&lt;font&gt;def removeDuplicates(arr):&lt;/font&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;font&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;noDuplicatesArr = []&lt;/font&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;font&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;for element in arr:&lt;/font&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;font&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;if element not in noDuplicatesArr:&lt;/font&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;font&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;noDuplicatesArr.append(element)&lt;/font&gt;&lt;/b&gt;&lt;/div&gt;&lt;b&gt;&lt;font&gt;&lt;span style=&quot;white-space: pre;&quot;&gt;&#x9;&lt;/span&gt;return noDuplicatesArr&lt;/font&gt;&lt;/b&gt;&lt;/div&gt;" style="text;html=1;align=left;verticalAlign=middle;whiteSpace=wrap;rounded=0;fontSize=14;" vertex="1" parent="1">
          <mxGeometry x="80" y="140" width="720" height="610" as="geometry" />
        </mxCell>
        <mxCell id="b6esr0sAbmWRh-eSNhls-5" value="&lt;div&gt;&lt;b&gt;Solution 2:&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;We put n = length of arr&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Time complexity: O(nlogn)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Explanation:&lt;/div&gt;&lt;div&gt;Sorting the array costs nlogn &lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;The for loop does n - 1 iterations because i starts at 1 and stops when it reaches n. And at each iteration, we are comparing 2 integers, O(1) cost, and appending an integer O(1) amortized cost, so the cost of an iteration is O(1)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;T(n) = nlogn + n -1 = O(nlogn)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Space complexity: O(n)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Explanation:&lt;/div&gt;&lt;div&gt;We are using extra space for the noDuplicatesArr that can contain n elements in the worst case, so:&lt;br&gt;&lt;br&gt;S(n) = O(n)&lt;br&gt;&lt;/div&gt;" style="text;html=1;align=left;verticalAlign=middle;whiteSpace=wrap;rounded=0;fontSize=14;" vertex="1" parent="1">
          <mxGeometry x="840" y="140" width="720" height="340" as="geometry" />
        </mxCell>
        <mxCell id="b6esr0sAbmWRh-eSNhls-6" value="&lt;div&gt;&lt;b&gt;Solution 3:&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;We put n = length of arr &lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Time complexity: O(n) &lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Explanation:&lt;/div&gt;&lt;div&gt;Inserting an element in a hash table costs O(1) in average, and we are doing it for each element.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;We also have the cost of converting the keys of the hash table into an array, which is n&lt;/div&gt;&lt;div&gt;T(n) = n + n = 2n = O(n)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Space complexity: O(n)&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Explanation: &lt;br&gt;The hash table can contain n elements in the worst case, when there are no duplicates, so:&lt;/div&gt;&lt;div&gt;S(n) = O(n)&lt;br&gt;&lt;/div&gt;" style="text;html=1;align=left;verticalAlign=middle;whiteSpace=wrap;rounded=0;fontSize=14;" vertex="1" parent="1">
          <mxGeometry x="1640" y="130" width="590" height="330" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
